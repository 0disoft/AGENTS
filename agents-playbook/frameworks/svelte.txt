### Svelte/SvelteKit 코드 생성을 위한 핵심 체크리스트 (2024년 10월 기준)

#### 1. Svelte 5와 룬(Runes)으로의 패러다임 전환
가장 큰 변화는 Svelte의 반응성 모델이 컴파일러 기반의 '암묵적' 방식에서 함수 기반의 '명시적' 방식으로 완전히 전환된 것입니다.

*   **명시적 반응성 (Explicit Reactivity):** Svelte 4의 암묵적 반응성(`let count = 0;`, `$: doubled = count * 2`)은 폐지되었습니다. 이제 **룬(Runes)**을 사용해 명시적으로 반응성을 선언해야 합니다.
    *   `$state()`: 반응형 상태를 선언합니다. (예: `let count = $state(0);`) [1, 2]
    *   `$derived()`: 파생된 상태를 계산합니다. (예: `const doubled = $derived(count * 2);`) [1]
    *   `$effect()`: 부수 효과(side effects)를 처리하며, 기존 `onMount`나 `$: console.log(...)`를 대체합니다.[1, 3]

*   **상태 관리의 변화:** `$state`는 `.svelte` 파일 외부(`.svelte.ts` 등)에서도 사용할 수 있어, 기존의 스토어(`svelte/store`)를 대체하는 강력한 상태 관리 패턴으로 사용될 수 있습니다.[4, 1]

*   **컴포넌트 Props 변경:** `export let` 대신 `$props()` 룬을 사용합니다. (예: `let { name } = $props();`) [5]

*   **슬롯(Slots)에서 스니펫(Snippets)으로:** UI 조각을 전달하는 방식이 `<slot>`에서 `{#snippet}`과 `{@render}`를 사용하는 스니펫으로 변경되었습니다. 스니펫은 더 유연하며 props로 전달할 수 있습니다.[6, 7]

*   **이벤트 핸들러 변경:** `on:click` 같은 Svelte 고유 문법 대신 표준 HTML 속성인 `onclick`을 사용합니다. `createEventDispatcher`는 콜백 함수를 props로 전달하는 패턴으로 대체되었습니다.[5]

#### 2. SvelteKit 2.0의 주요 파괴적 변경 (Breaking Changes)
SvelteKit 2.0으로 업데이트되면서 코드베이스 전반에 걸쳐 수정이 필요한 몇 가지 중요한 변경 사항이 있었습니다.

*   **`error` 및 `redirect` 사용법:** 더 이상 `throw` 키워드와 함께 사용하지 않습니다. 함수를 직접 호출하면 됩니다. (예: `throw redirect(307, '/')` -> `redirect(307, '/')`) [8, 9, 10]

*   **쿠키 설정:** `cookies.set()` 사용 시 `path` 옵션(예: `{ path: '/' }`)을 반드시 명시해야 합니다.[8, 10]

*   **`load` 함수의 프로미스 처리:** `load` 함수가 반환하는 객체의 최상위 프로미스는 더 이상 자동으로 `await`되지 않습니다. 렌더링을 차단해야 할 경우 명시적으로 `await`를 사용해야 합니다. 이는 데이터 스트리밍 동작을 일관성 있게 만듭니다.[9, 10]

#### 3. SvelteKit의 새로운 핵심 기능
풀스택 프레임워크로서의 기능이 대폭 강화되었습니다.

*   **얕은 라우팅 (Shallow Routing):** `load` 함수를 다시 실행하지 않고 URL을 변경할 수 있는 기능입니다. `$app/navigation`의 `pushState`와 `replaceState`를 사용하여 모달이나 탭 UI 상태를 URL과 동기화할 때 유용합니다.[11, 12, 13]

*   **`reroute` 훅:** 국제화(i18n) 구현을 획기적으로 개선한 기능입니다. `hooks.js` 파일에서 URL을 실제 렌더링될 라우트로 매핑할 수 있습니다. (예: `/de/ueber-uns`를 `/about` 라우트로 처리) [14, 15]

*   **데이터 스트리밍:** 서버 `load` 함수에서 중첩된 프로미스(nested promise)를 반환하여 데이터를 스트리밍할 수 있습니다. 페이지의 일부를 먼저 렌더링하고 오래 걸리는 데이터는 나중에 받아와 사용자 경험을 향상시킵니다.[16, 17]

*   **폼 액션 개선:** 원격 폼 함수(remote form functions)가 `FormData` 대신 파싱된 순수 자바스크립트 객체(POJO)를 인자로 받도록 변경되어 유효성 검사가 단순해졌습니다.[18]

#### 4. 툴링 및 타입 안전성 강화
개발자 경험과 코드의 안정성을 높이는 업데이트가 있었습니다.

*   `svelte.config.ts`를 공식 지원하여 타입스크립트 기반의 프로젝트 설정이 가능해졌습니다.[10]
*   `$app/types` 모듈이 추가되어 `RouteId`, `Pathname` 등 라우팅 관련 타입을 안전하게 사용할 수 있습니다.[10]

#### 5. LLM을 위한 종합 조언
*   2023년 말 이전의 Svelte/SvelteKit 코드는 대부분 Svelte 4 문법(암묵적 반응성, `$:`, 슬롯 등)을 사용하므로, 최신 코드를 생성할 때는 Svelte 5의 룬 기반 문법을 사용해야 합니다.
*   Svelte 5로의 전환은 단순한 문법 변경이 아닌, 반응성을 다루는 근본적인 멘탈 모델의 변화임을 인지해야 합니다.
*   많은 라이브러리와 예제 코드가 Svelte 5로 마이그레이션하는 과정에 있을 수 있으므로, 두 가지 스타일이 혼재된 코드를 접할 수 있습니다.[19]